<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Webcam</title>
    <link rel="stylesheet" href="/static/styles.css">
    <link href="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.css" rel="stylesheet">
    <script src="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.js"></script>
    <style>
          .container {
                    max-width: 800px;
                    margin: 0 auto;
                    padding: 20px;
                }
                
                .video-container {
                    margin-top: 20px;
                    text-align: center;
                }
                
                .controls {
                    margin: 15px 0;
                }
                
                .control-btn {
                    padding: 10px 20px;
                    margin: 0 10px;
                    background-color: #4CAF50;
                    color: white;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 16px;
                    transition: background-color 0.3s;
                }
                
                .control-btn:hover {
                    background-color: #45a049;
                }
                
                .control-btn:disabled {
                    background-color: #cccccc;
                    cursor: not-allowed;
                }
                
                .result-container {
                    margin: 15px 0;
                    padding: 10px;
                    background-color: #f9f9f9;
                    border-radius: 4px;
                    border: 1px solid #ddd;
                }
                
                #gestureResult {
                    font-size: 24px;
                    font-weight: bold;
                    margin: 0;
                    color: #333;
                }
                
                canvas {
                    max-width: 100%;
                    height: auto;
                    border: 2px solid #4CAF50;
                    border-radius: 4px;
                }
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f9;
            color: #333;
        }

        header {
            background-color: #4CAF50;
            color: white;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            margin: 0;
            font-size: 2rem;
        }

        nav {
            display: flex;
            gap: 1rem;
        }

        nav a {
            color: white;
            text-decoration: none;
            font-size: 1rem;
            font-weight: bold;
            transition: color 0.3s;
        }

        nav a:hover {
            color: #d4f4d4;
        }

        main {
            text-align: center;
            padding: 2rem;
        }

        main h2 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
        }

        main p {
            font-size: 1.2rem;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
        }

        .features {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 2rem;
            margin-top: 2rem;
        }

        .feature {
            background-color: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            text-align: center;
            width: 250px;
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .feature:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
        }

        .feature h3 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
        }

        .feature p {
            font-size: 1rem;
            color: #666;
        }

        footer {
            margin-top: 2rem;
            font-size: 0.9rem;
            color: #666;
            text-align: center;
            padding: 1rem;
            background-color: #f4f4f9;
        }

        footer a {
            color: #4CAF50;
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }
        
        /* MediaPipe specific styles */
        video {
            clear: both;
            display: block;
            transform: rotateY(180deg);
            -webkit-transform: rotateY(180deg);
            -moz-transform: rotateY(180deg);
        }

        .output_canvas {
            transform: rotateY(180deg);
            -webkit-transform: rotateY(180deg);
            -moz-transform: rotateY(180deg);
            position: absolute;
            left: 0;
            top: 0;
        }

        .output {
            display: none;
            width: 100%;
            font-size: calc(8px + 1.2vw);
            margin-top: 10px;
            padding: 10px;
            background-color: rgba(0, 127, 139, 0.8);
            color: white;
            border-radius: 4px;
        }

        .video-container {
            position: relative;
            width: fit-content;
            margin: 0 auto;
        }
    </style>
   
</head>
<body>
    <header>
        <h1>SignSpeak</h1>
        <nav>
            <a href="index.html">Home</a>
            <a href="text_to_sign.html">Text to Sign</a>
            <a href="image_to_sign.html">Image to Sign</a>
            <a href="webcam.html">Webcam</a>
        </nav>
    </header>
    <main>
        <h2>Webcam</h2>
        <p>Experience real-time gesture recognition through your webcam:</p>
        <p style="font-size: 1.1rem; color: #555; max-width: 800px; margin: 0 auto;">
            Our advanced gesture recognition system uses cutting-edge technology to interpret hand gestures in real-time. 
            This feature is perfect for enhancing communication and accessibility for individuals who rely on sign language.
        </p>
        <p style="color: red; font-weight: bold; text-align: center;">Beta: Some features may not work as expected.</p>
        <div class="container">
            <h1>Sign Language Detection</h1>
            
            <div class="video-container">
                <video id="webcam" autoplay playsinline></video>
                <canvas class="output_canvas" id="output_canvas" width="1280" height="720"></canvas>
                <p id="gesture_output" class="output"></p>
                
                <!-- Controls -->
                <div class="controls">
                    <button id="webcamButton" class="control-btn mdc-button mdc-button--raised">
                        <span class="mdc-button__ripple"></span>
                        <span class="mdc-button__label">ENABLE WEBCAM</span>
                    </button>
                </div>
            </div>
        </div>

        <script type="module">
            import { GestureRecognizer, FilesetResolver, DrawingUtils } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

            const demosSection = document.getElementById("demos");
            let gestureRecognizer;
            let runningMode = "IMAGE";
            let enableWebcamButton;
            let webcamRunning = false;
            const videoHeight = "360px";
            const videoWidth = "480px";

            // Initialize the GestureRecognizer
            const createGestureRecognizer = async () => {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: "https://rgxalrnmnlbmskupyhcm.supabase.co/storage/v1/object/public/signlanguage//gesture_recognizer.task",
                        delegate: "GPU"
                    },
                    runningMode: runningMode
                });
            };

            createGestureRecognizer();

            const video = document.getElementById("webcam");
            const canvasElement = document.getElementById("output_canvas");
            const canvasCtx = canvasElement.getContext("2d");
            const gestureOutput = document.getElementById("gesture_output");

            function hasGetUserMedia() {
                return !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
            }

            if (hasGetUserMedia()) {
                enableWebcamButton = document.getElementById("webcamButton");
                enableWebcamButton.addEventListener("click", enableCam);
            } else {
                console.warn("getUserMedia() is not supported by your browser");
            }

            function enableCam(event) {
                if (!gestureRecognizer) {
                    alert("Please wait for gestureRecognizer to load");
                    return;
                }

                if (webcamRunning === true) {
                    webcamRunning = false;
                    enableWebcamButton.innerText = "ENABLE CAMERA";
                    // Stop the webcam
                    const stream = video.srcObject;
                    const tracks = stream.getTracks();
                    tracks.forEach(track => track.stop());
                    video.srcObject = null;
                } else {
                    webcamRunning = true;
                    enableWebcamButton.innerText = "DISABLE CAMERA";
                    // Start the webcam
                    const constraints = {
                        video: true
                    };
                    navigator.mediaDevices.getUserMedia(constraints).then(function(stream) {
                        video.srcObject = stream;
                        video.addEventListener("loadeddata", predictWebcam);
                    });
                }
            }

            let lastVideoTime = -1;
            let results = undefined;

            async function predictWebcam() {
                const webcamElement = document.getElementById("webcam");
                
                if (runningMode === "IMAGE") {
                    runningMode = "VIDEO";
                    await gestureRecognizer.setOptions({ runningMode: "VIDEO" });
                }

                let nowInMs = Date.now();
                if (video.currentTime !== lastVideoTime) {
                    lastVideoTime = video.currentTime;
                    results = gestureRecognizer.recognizeForVideo(video, nowInMs);
                }

                canvasCtx.save();
                canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                const drawingUtils = new DrawingUtils(canvasCtx);

                canvasElement.style.height = videoHeight;
                webcamElement.style.height = videoHeight;
                canvasElement.style.width = videoWidth;
                webcamElement.style.width = videoWidth;

                if (results.landmarks) {
                    for (const landmarks of results.landmarks) {
                        drawingUtils.drawConnectors(landmarks, GestureRecognizer.HAND_CONNECTIONS, {
                            color: "#00FF00",
                            lineWidth: 5
                        });
                        drawingUtils.drawLandmarks(landmarks, {
                            color: "#FF0000",
                            lineWidth: 2
                        });
                    }
                }

                canvasCtx.restore();

                if (results.gestures.length > 0) {
                    gestureOutput.style.display = "block";
                    gestureOutput.style.width = videoWidth;
                    const categoryName = results.gestures[0][0].categoryName;
                    const categoryScore = parseFloat(results.gestures[0][0].score * 100).toFixed(2);
                    const handedness = results.handednesses[0][0].displayName;
                    gestureOutput.innerText = `Gesture: ${categoryName}\nConfidence: ${categoryScore}%\nHand: ${handedness}`;
                } else {
                    gestureOutput.style.display = "none";
                }

                // Call this function again to keep predicting when the browser is ready and webcam is running
                if (webcamRunning === true) {
                    window.requestAnimationFrame(predictWebcam);
                }
            }
        </script>
        <script src="{{ url_for('static', filename='js/webrtc.js') }}"></script>
   
    </main>
    <footer>
        <p>Developed as part of the Capstone Project | <a href="#">Learn More</a></p>
    </footer>
</body>
</html>